\documentclass[10pt,a4paper]{article}
\usepackage{blindtext}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}

\lstset{
    inputencoding=utf8,
    extendedchars=true,
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1 {Ñ}{{\~N}}1
}
\input{AEDmacros}
\newcommand{\notimplies}{\;\not\!\!\!\implies}
\title{Algoritmos y Estructuras de Datos III}
\author{Tomás Agustín Hernández}
\date{}

\begin{document}
\maketitle

\begin{figure}[b]
    \centering
    \begin{tikzpicture}[remember picture,overlay]
        \node[anchor=south east, inner sep=0pt, xshift=-1cm, yshift=2cm] at (current page.south east) {
            \begin{minipage}[b]{0.5\textwidth}
                \includegraphics[width=\linewidth]{logo_uba.jpg}
                \label{fig:bottom}
            \end{minipage}
        };
    \end{tikzpicture}
\end{figure}

\newpage
\section*{Complejidad Computacional (repaso)}
\subsection*{Problema}
Descripción de los datos de entrada y la respuesta a proporcionar para cada uno de los datos de entrada.
\subsection*{Instancia de un Problema}
Es un juego válido de datos de entrada.
\subsection*{Máquina RAM}
Supongamos una Máquina RAM. 
\begin{itemize}
    \item La memoria está dada por una sucesión de celdas numeradas. Cada \textbf{celda} puede almacenar un valor de \textbf{b bits}. 
    \item Supondremos habitualmente que esos \textbf{b bits} de cada celda están fijos, y suponemos que todos los datos que maneja el algoritmo se pueden almacenar con \textbf{b bits}. 
    \textbf{Ej.}: Lo que quiere decir esto es que suponemos que todas las celdas son de 8 bits, y los datos que maneja el algoritmo también son de 8 bits.
    \item Se tiene un programa imperativo que NO está almacenado en memoria que está compuesto por asignaciones y las estructuras de control habituales.
    \item Las asignaciones acceden a las celdas de memoria y realizan las operaciones estándar sobre los tipos de datos primitivos habituales.
\end{itemize}
Cada una de las instrucciones que se ejecuten tienen un tiempo de ejecución asociado
\begin{itemize}
    \item El acceso a cualquier celda de memoria, tanto lectura como escritura es O(1).
    \item Las asignaciones y el manejo de las estructuras de control se realiza en O(1).
    \item Las operaciones entre valores lógicos son O(1).
\end{itemize}
Las operaciones entre enteros/reales dependen de b
\begin{itemize}
    \item Las sumas y restas son O(b).
    \item Las multiplicaciones y divisiones son O(b log b)
\end{itemize}
\textbf{Nota}: Si b está fijo, entonces las operaciones entre enteros/reales es O(1).
\subsection*{Tiempo de Ejecución de un Algoritmo}
Sea A un algoritmo, su tiempo de ejecución es: $T_{A}(I)$ donde esto indica que es la suma de los tiempos de ejecución del algoritmo en una instancia dada I. \\
\textbf{$\longitud{I}$}: Cantidad de bits necesarios para almacenar los datos de entrada de I. \\ \\
\textbf{Nota}: Si \textbf{b está fijo} y la entrada ocupa n celdas de memoria entonces $\longitud{I} = bn = O(n)$
\subsection*{Complejidad de un Algoritmo}
Sea A un algoritmo, su complejidad es: $f_{A}(n) = max_{I:\longitud{I}=n} \ T_{A}(I)$ donde esto indica que la complejidad de un algoritmo A dado un n cualquiera, es el que de mayor tiempo de ejecución tiene en una instancia dada I. 
\subsection*{Cotas}
\textbf{Cota Superior (O)}: $f (n) \in O(g(n)) \iff \exists c \in R>0, n_{0} \in N \ tal \ que \
\forall n \ge n_{0} : f(n) \le c \ast g(n)$  \\
\textbf{Cota Inferior ($\Omega$)}: $f (n) \in \Omega(g(n)) \iff \exists c \in R>0, n_{0} \in N \ tal \ que \ \forall n \ge n_{0} : f(n) \ge c \ast g(n) $ \\
\textbf{Cota Ajustada ($\theta$)}:  $f (n) \in \theta(g(n)) \iff f (n) \in O(g(n)) \ y \ f (n) \in \Omega(g(n)).\ Es \ decir, \ \theta(g(n)) = O(g(n)) \cap \Omega(g(n))$
\subsection*{Tipos de Funciones}
\begin{itemize}
    \item O(n): lineal
    \item $O(n^{2})$: cuadrático
    \item $O(n^{3})$: cúbico
    \item $O(n^{k}) \ k \in \nat$: polinomial. Ej.: $O(n^{4}), \ O(n^{5})$
    \item $O(log \ n)$: logarítmico. 
    \item $O(d^{n}) \ d \in \float_{>1}$: exponencial. Ej.: $ O(2^{n}), \ O(4^{n})$
\end{itemize}
\section*{Algoritmos Satisfactorios y No Satisfactorios}
Un Algoritmo Satisfactorio es un algoritmo que tiene un costo menor a otro. \\
Los algoritmos polinomiales se consideran satisfactorios (cuanto menor sea el grado, mejor). \\
Los algoritmos supra-polinomiales se consideran no satisfactorios. 
\section*{Problema de Optimización}
Sea $x \in S$, un problema de optimización consiste en encontrar la mejor solución dentro de un conjunto: 
\begin{itemize}
    \item $z^{*} = max \ f(x)$
    \item $z^{*} = min \ f(x)$
\end{itemize}
\textbf{Función Objetivo}: Es una función de la forma $f:S\implies \float$
\begin{itemize}
    \item El conjunto S es la \textbf{región factible}.
    \item Los elementos $x \in S$ se llaman \textbf{soluciones factibles}.
    \item El valor $z^{x} \in \float$ es el \textbf{valor óptimo} del problema, y cualquier solución factible $x^{*} \in S \ / \ f(x^{*}) = z^{x}$ se llama un \textbf{óptimo} del problema
\end{itemize}
\section*{Algoritmos de Fuerza Bruta}
También llamado búsqueda exhaustiva o generate and test. Genera todas las soluciones factibles y se queda con la mejor (la que cumpla las restricciones que necesitamos). Suele ser fácil de implementar y es un algoritmo exacto: si hay solución, siempre la encuentra. \\
Lo malo es su complejidad (suele ser exponencial) \\
\textbf{Ej.}: Imaginemos que tenemos un tablero de ajedrez y tenemos que buscar las soluciones en las cuales ninguna dama amenace a otra. Una solución por fuerza bruta sería buscar todas las soluciones que existen, y de ahí agarrar las que me sirvan. \\ 
\textbf{Ej.}: Imaginemos que tenemos que resolver un Sudoku, si usaramos un casillero de 9x9 y quisieramos aplicar un algoritmo de fuerza bruta, es decir, primero buscar todas las posibles permutaciones 1966270504755529.... posibilidades y de todas estas posibilidades ver cual es solución. Esto es muy tedioso y lento, hay una mejor opción que la fuerza y bruta, y es el Backtracking.
\section*{Backtracking}
Es una técnica (de fuerza bruta) que consiste en una exploración ordenada del espacio de soluciones por medio de la extensión de soluciones parciales \textbf{(las soluciones se van armando recursivamente, si llego a un paso donde veo que no me sirve, vuelvo atrás y hago las otras llamadas)}. \\
\textbf{Cada posible extensión de la solución parcial se explora haciendo recursión sobre la nueva solución extendida}, esto se puede ver como un árbol de decisiones que podemos ir recorriendo nodo por nodo, y si veo que el siguiente nodo no me sirve, vuelvo hacia atrás y evalúo las demás. \\
\[\begin{minipage}[b]{0.7\textwidth}
    \includegraphics[width=\linewidth]{assets/backtracking_arbol1.png}
\end{minipage}\]
Comenzamos evaluando desde la raíz, el nodo de la izquierda cumple hasta ahora nuestra posible solución, nos movemos a ese nodo y luego, evaluando su nodo de la izquierda vemos que se rompe, es decir, alguna restricción que pusimos no se cumple, por lo tanto no tiene sentido seguir explorando las demás soluciones. \\
\[\begin{minipage}[b]{0.7\textwidth}
    \includegraphics[width=\linewidth]{assets/backtracking_arbol.png}
\end{minipage}\]
Vemos que efectivamente, habiendo vuelto a la raíz, ahora sí encontramos un camino mejor que el camino del nodo de la izquierda. Por lo tanto, podemos seguir evaluando hacia abajo. \\
Cada vez que encontremos un nodo que no es solución, volvemos al nodo anterior y evaluamos los demás hijos. Si ningún nodo hijo cumple de ese nodo, entonces tenemos que volver más atrás todavía. \\
\textbf{Podas por factibilidad}: Evito explorar nodos no factibles. \\
\textbf{Podas por optimalidad}: Evito explorar nodos subóptimos. \\ 
\textbf{Branch and bound}: Uso la solución más óptima para comparar y ver si exploro eso no. \\

\textbf{Todas las soluciones}:
\begin{lstlisting}
    algoritmo BT(a,k)
        si a es solución entonces
            procesar(a)
            retornar
        sino
            para cada a' en Sucesores(a,k)
            BT(a', k + 1)
            fin para
        fin si
        retornar
\end{lstlisting}
\textbf{Una solución}:
\begin{lstlisting}
    algoritmo BT(a,k)
    si a es solución entonces
        sol <- a
        encontro <- true
    sino
        para cada a' en Sucesores(a,k)
            BT(a', k + 1)
            si encontro entonces
                retornar
            fin si
        fin para
    fin si
    retornar
\end{lstlisting}
\textbf{Ej.}: Resolver un sudoku se resuelve en forma muy eficiente con un algoritmo de backtracking.

\end{document} 
