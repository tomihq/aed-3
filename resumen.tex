\documentclass[10pt,a4paper]{article}
\usepackage{blindtext}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}

\lstset{
    inputencoding=utf8,
    extendedchars=true,
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1 {Ñ}{{\~N}}1
}
\input{AEDmacros}
\newcommand{\notimplies}{\;\not\!\!\!\implies}
\title{Algoritmos y Estructuras de Datos III}
\author{Tomás Agustín Hernández}
\date{}

\begin{document}
\maketitle

\begin{figure}[b]
    \centering
    \begin{tikzpicture}[remember picture,overlay]
        \node[anchor=south east, inner sep=0pt, xshift=-1cm, yshift=2cm] at (current page.south east) {
            \begin{minipage}[b]{0.5\textwidth}
                \includegraphics[width=\linewidth]{logo_uba.jpg}
                \label{fig:bottom}
            \end{minipage}
        };
    \end{tikzpicture}
\end{figure}

\newpage
\section*{Complejidad Computacional (repaso)}
\subsection*{Problema}
Descripción de los datos de entrada y la respuesta a proporcionar para cada uno de los datos de entrada.
\subsection*{Instancia de un Problema}
Es un juego válido de datos de entrada.
\subsection*{Máquina RAM}
Supongamos una Máquina RAM. 
\begin{itemize}
    \item La memoria está dada por una sucesión de celdas numeradas. Cada \textbf{celda} puede almacenar un valor de \textbf{b bits}. 
    \item Supondremos habitualmente que esos \textbf{b bits} de cada celda están fijos, y suponemos que todos los datos que maneja el algoritmo se pueden almacenar con \textbf{b bits}. 
    \textbf{Ej.}: Lo que quiere decir esto es que suponemos que todas las celdas son de 8 bits, y los datos que maneja el algoritmo también son de 8 bits.
    \item Se tiene un programa imperativo que NO está almacenado en memoria que está compuesto por asignaciones y las estructuras de control habituales.
    \item Las asignaciones acceden a las celdas de memoria y realizan las operaciones estándar sobre los tipos de datos primitivos habituales.
\end{itemize}
Cada una de las instrucciones que se ejecuten tienen un tiempo de ejecución asociado
\begin{itemize}
    \item El acceso a cualquier celda de memoria, tanto lectura como escritura es O(1).
    \item Las asignaciones y el manejo de las estructuras de control se realiza en O(1).
    \item Las operaciones entre valores lógicos son O(1).
\end{itemize}
Las operaciones entre enteros/reales dependen de b
\begin{itemize}
    \item Las sumas y restas son O(b).
    \item Las multiplicaciones y divisiones son O(b log b)
\end{itemize}
\textbf{Nota}: Si b está fijo, entonces las operaciones entre enteros/reales es O(1).
\subsection*{Tiempo de Ejecución de un Algoritmo}
Sea A un algoritmo, su tiempo de ejecución es: $T_{A}(I)$ donde esto indica que es la suma de los tiempos de ejecución del algoritmo en una instancia dada I. \\
\textbf{$\longitud{I}$}: Cantidad de bits necesarios para almacenar los datos de entrada de I. \\ \\
\textbf{Nota}: Si \textbf{b está fijo} y la entrada ocupa n celdas de memoria entonces $\longitud{I} = bn = O(n)$
\subsection*{Complejidad de un Algoritmo}
Sea A un algoritmo, su complejidad es: $f_{A}(n) = max_{I:\longitud{I}=n} \ T_{A}(I)$ donde esto indica que la complejidad de un algoritmo A dado un n cualquiera, es el que de mayor tiempo de ejecución tiene en una instancia dada I. 
\subsection*{Cotas}
\textbf{Cota Superior (O)}: $f (n) \in O(g(n)) \iff \exists c \in R>0, n_{0} \in N \ tal \ que \
\forall n \ge n_{0} : f(n) \le c \ast g(n)$  \\
\textbf{Cota Inferior ($\Omega$)}: $f (n) \in \Omega(g(n)) \iff \exists c \in R>0, n_{0} \in N \ tal \ que \ \forall n \ge n_{0} : f(n) \ge c \ast g(n) $ \\
\textbf{Cota Ajustada ($\theta$)}:  $f (n) \in \theta(g(n)) \iff f (n) \in O(g(n)) \ y \ f (n) \in \Omega(g(n)).\ Es \ decir, \ \theta(g(n)) = O(g(n)) \cap \Omega(g(n))$
\subsection*{Tipos de Funciones}
\begin{itemize}
    \item O(n): lineal
    \item $O(n^{2})$: cuadrático
    \item $O(n^{3})$: cúbico
    \item $O(n^{k}) \ k \in \nat$: polinomial. Ej.: $O(n^{4}), \ O(n^{5})$
    \item $O(log \ n)$: logarítmico. 
    \item $O(d^{n}) \ d \in \float_{>1}$: exponencial. Ej.: $ O(2^{n}), \ O(4^{n})$
\end{itemize}
\section*{Algoritmos Satisfactorios y No Satisfactorios}
Un Algoritmo Satisfactorio es un algoritmo que tiene un costo menor a otro. \\
Los algoritmos polinomiales se consideran satisfactorios (cuanto menor sea el grado, mejor). \\
Los algoritmos supra-polinomiales se consideran no satisfactorios. 
\section*{Problema de Optimización}
Sea $x \in S$, un problema de optimización consiste en encontrar la mejor solución dentro de un conjunto: 
\begin{itemize}
    \item $z^{*} = max \ f(x)$
    \item $z^{*} = min \ f(x)$
\end{itemize}
\textbf{Función Objetivo}: Es una función de la forma $f:S\implies \float$
\begin{itemize}
    \item El conjunto S es la \textbf{región factible}.
    \item Los elementos $x \in S$ se llaman \textbf{soluciones factibles}.
    \item El valor $z^{x} \in \float$ es el \textbf{valor óptimo} del problema, y cualquier solución factible $x^{*} \in S \ / \ f(x^{*}) = z^{x}$ se llama un \textbf{óptimo} del problema
\end{itemize}
\section*{Algoritmos de Fuerza Bruta}
También llamado búsqueda exhaustiva o generate and test. Genera todas las soluciones factibles y se queda con la mejor. Suele ser fácil de implementar y es un algoritmo exacto: si hay solución, siempre la encuentra. \\
Lo malo es su complejidad (suele ser exponencial)
\section*{Backtracking}
Es una técnica que consiste en una exploración ordenada del espacio de soluciones por medio de la extensión de soluciones parciales. \\
Cada posible extensión de la solución parcial se explora haciendo recursión sobre la nueva solución extendida, esto se puede ver como un árbol y que podemos podarlo (descartar configuraciones antes de explorarlas) al árbol para reducir el espacio de búsqueda. \\
\textbf{Todas las soluciones}:
\begin{lstlisting}
    algoritmo BT(a,k)
        si a es solución entonces
            procesar(a)
            retornar
        sino
            para cada a' en Sucesores(a,k)
            BT(a', k + 1)
            fin para
        fin si
        retornar
\end{lstlisting}
\textbf{Una solución}:
\begin{lstlisting}
    algoritmo BT(a,k)
    si a es solución entonces
        sol <- a
        encontro <- true
    sino
        para cada a' en Sucesores(a,k)
            BT(a', k + 1)
            si encontro entonces
                retornar
            fin si
        fin para
    fin si
    retornar
\end{lstlisting}
\textbf{Ej.}: Resolver un sudoku se resuelve en forma muy eficiente con un algoritmo de backtracking.
\section*{Fuerza Bruta}
Un algoritmo de fuerza bruta (también llamado búsqueda exhaustiva) analiza todas las posibles configuraciones. \\
\textbf{Ej.}: Imaginemos que tenemos un tablero de ajedrez y tenemos que buscar las soluciones en las cuales ninguna dama amenace a otra. Una solución por fuerza bruta sería buscar todas las soluciones que existen, y de ahí agarrar las que me sirvan.
\end{document} 
